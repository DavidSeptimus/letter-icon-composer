<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Letter Icon Composer</title>
<link rel="icon" type="image/svg+xml" media="(prefers-color-scheme: light)" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='6.5' fill='%23E7EFFD' stroke='%233574F0'/%3E%3Cpath fill='%233574F0' d='M7.16 4.28L7.16 11.72L6.03 11.72L6.03 4.28L7.16 4.28ZM9.33 4.40L9.33 4.40Q9.59 4.40 9.78 4.54Q9.97 4.67 9.97 5.01L9.97 5.01Q9.97 5.35 9.78 5.49Q9.59 5.63 9.33 5.63L9.33 5.63Q9.06 5.63 8.88 5.49Q8.70 5.35 8.70 5.01L8.70 5.01Q8.70 4.67 8.88 4.54Q9.06 4.40 9.33 4.40ZM8.76 6.43L9.89 6.43L9.89 11.72L8.76 11.72L8.76 6.43Z'/%3E%3C/svg%3E">
<link rel="icon" type="image/svg+xml" media="(prefers-color-scheme: dark)" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='none' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='6.5' fill='%2325324D' stroke='%23548AF7'/%3E%3Cpath fill='%23548AF7' d='M7.16 4.28L7.16 11.72L6.03 11.72L6.03 4.28L7.16 4.28ZM9.33 4.40L9.33 4.40Q9.59 4.40 9.78 4.54Q9.97 4.67 9.97 5.01L9.97 5.01Q9.97 5.35 9.78 5.49Q9.59 5.63 9.33 5.63L9.33 5.63Q9.06 5.63 8.88 5.49Q8.70 5.35 8.70 5.01L8.70 5.01Q8.70 4.67 8.88 4.54Q9.06 4.40 9.33 4.40ZM8.76 6.43L9.89 6.43L9.89 11.72L8.76 11.72L8.76 6.43Z'/%3E%3C/svg%3E">
<script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/paper@0.12.18/dist/paper-full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/paperjs-offset@1.0.8/dist/paperjs-offset.min.js"></script>
<style>
  :root, [data-theme="islands-dark"] {
    --bg: #1E1F22;
    --surface: #26282b;
    --surface2: #2B2D30;
    --border: #393B40;
    --text: #D1D3D9;
    --text-dim: #9da0a8;
    --accent: #3574F0;
    --accent-hover: #467FF2;
    --error: #F75464;
  }
  [data-theme="islands-light"] {
    --bg: #EBECF0;
    --surface: #F7F8FA;
    --surface2: #FFFFFF;
    --border: #DFE1E5;
    --text: #27282E;
    --text-dim: #6C707E;
    --accent: #3574F0;
    --accent-hover: #315FBD;
    --error: #C7362B;
  }
  [data-theme="purple"] {
    --bg: #1e1e2e;
    --surface: #282840;
    --surface2: #32324a;
    --border: #44446a;
    --text: #e0e0f0;
    --text-dim: #9090b0;
    --accent: #7c8aff;
    --accent-hover: #9aa4ff;
    --error: #f38ba8;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; scrollbar-color: var(--border) transparent; }
  ::-webkit-scrollbar { width: 8px; height: 8px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 24px;
  }
  .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    max-width: 1400px;
    margin: 0 auto 24px;
  }
  h1 { font-size: 20px; font-weight: 600; margin-bottom: 4px; }
  .subtitle { color: var(--text-dim); font-size: 13px; }
  .socials {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-shrink: 0;
  }
  .socials a {
    color: var(--text-dim);
    transition: color 0.15s;
    display: flex;
    align-items: center;
  }
  .socials a:hover { color: var(--text); }

  .layout {
    display: grid;
    grid-template-columns: 280px 1fr 280px;
    gap: 24px;
    max-width: 1400px;
    margin: 0 auto;
  }

  .panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 20px;
  }

  .section { margin-bottom: 20px; }
  .section:last-child { margin-bottom: 0; }
  .section-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-dim);
    margin-bottom: 10px;
    cursor: pointer;
    list-style: none;
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }
  .section-title::-webkit-details-marker { display: none; }
  .section-title::before {
    content: '';
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 4px solid var(--text-dim);
    border-top: 3px solid transparent;
    border-bottom: 3px solid transparent;
    transition: transform 0.15s;
    flex-shrink: 0;
  }
  details.section[open] > .section-title::before {
    transform: rotate(90deg);
  }
  details.section:not([open]) > .section-title {
    margin-bottom: 0;
  }
  details.section > *:not(summary) {
    opacity: 1;
    transition: opacity 0.15s ease;
  }
  details.section:not([open]) > *:not(summary) {
    opacity: 0;
  }

  label {
    display: block;
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 4px;
  }

  input[type="text"], select {
    width: 100%;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    padding: 7px 10px;
    font-size: 13px;
    outline: none;
  }
  input:focus, select:focus {
    border-color: var(--accent);
  }

  .letter-input {
    font-size: 24px;
    text-align: center;
    font-weight: 600;
    padding: 8px;
  }

  .color-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 8px;
  }
  .color-field {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .color-field input[type="color"] {
    width: 28px;
    height: 28px;
    border: 1px solid var(--border);
    border-radius: 4px;
    cursor: pointer;
    padding: 0;
    background: none;
  }
  .color-field input[type="text"] {
    width: 80px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
  }
  .color-field input[type="text"].invalid {
    border-color: var(--error);
    outline-color: var(--error);
  }

  .preset-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 6px;
    margin-bottom: 12px;
  }
  .preset-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 8px;
    cursor: pointer;
    color: var(--text);
    font-size: 11px;
    transition: border-color 0.15s;
  }
  .preset-divider {
    grid-column: 1 / -1;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    color: var(--text-dim);
    padding: 4px 0 0;
    border-top: 1px solid var(--border);
    margin-top: 2px;
  }
  .preset-btn:hover { border-color: var(--accent); }
  .preset-btn.active { border-color: var(--accent); background: rgba(124,138,255,0.1); }
  .preset-swatch {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid currentColor;
    flex-shrink: 0;
  }

  .shape-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
  }
  .shape-btn {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px;
    cursor: pointer;
    text-align: center;
    color: var(--text);
    font-size: 11px;
    transition: border-color 0.15s;
  }
  .shape-btn:hover { border-color: var(--accent); }
  .shape-btn.active { border-color: var(--accent); background: rgba(124,138,255,0.1); }
  .shape-btn svg { display: block; margin: 0 auto 4px; }

  /* Preview area */
  .preview-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .preview-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
  }
  .preview-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    text-align: center;
  }
  .preview-card-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-dim);
    margin-bottom: 12px;
  }
  .preview-canvas-wrap {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 24px;
    margin-bottom: 12px;
  }
  .preview-actual {
    border: 1px dashed var(--border);
    padding: 4px;
    border-radius: 4px;
  }
  .preview-actual span {
    display: block;
    font-size: 9px;
    color: var(--text-dim);
    margin-top: 4px;
  }
  .preview-zoomed { position: relative; display: inline-block; --cell: 4px; }
  .preview-zoomed > svg { display: block; position: relative; z-index: 1; }
  .preview-light .preview-zoomed { background: #f5f5f5; border-radius: 8px; padding: 16px; }
  .preview-dark .preview-zoomed { background: #2b2b2b; border-radius: 8px; padding: 16px; }
  .preview-zoomed.checkerboard::before {
    content: '';
    position: absolute;
    top: 16px;
    left: 16px;
    width: 128px;
    height: 128px;
    background-color: #ffffff;
    background-image:
      linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
      linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
      linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
    background-size: calc(var(--cell) * 2) calc(var(--cell) * 2);
    background-position: 0 0, 0 var(--cell), var(--cell) calc(-1 * var(--cell)), calc(-1 * var(--cell)) 0;
    pointer-events: none;
  }
  .preview-zoomed .pixel-grid {
    display: none;
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 2;
    pointer-events: none;
  }
  .preview-zoomed .pixel-grid svg { display: block; }
  .preview-zoomed.show-grid .pixel-grid { display: block; }

  .preview-zoomed .size-guide {
    display: none;
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 3;
    pointer-events: none;
  }
  .preview-zoomed .size-guide svg { display: block; }
  .preview-zoomed.show-guide-shape .size-guide-shape { display: block; }
  .preview-zoomed.show-guide-letter .size-guide-letter { display: block; }
  .preview-zoomed.show-guide-notch .size-guide-notch { display: block; }
  .preview-zoomed.show-guide-badge .size-guide-badge { display: block; }

  .toggle-separator {
    width: 1px;
    height: 20px;
    background: var(--border);
    margin: 0 4px;
    align-self: center;
  }

  .preview-toggles {
    display: flex;
    gap: 4px;
    justify-content: center;
    margin-bottom: 12px;
  }

  .btn-row {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .btn {
    background: var(--accent);
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 6px 14px;
    font-size: 12px;
    cursor: pointer;
    font-weight: 500;
    transition: background 0.15s;
  }
  .btn:hover { background: var(--accent-hover); }
  .btn-secondary {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
  }
  .btn-secondary:hover { background: var(--surface2); }

  /* SVG Code panel */
  .code-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
  }
  .code-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
  }
  .code-tabs {
    display: flex;
    gap: 0;
  }
  .file-size {
    font-size: 11px;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    color: var(--text-dim);
  }
  .code-tab {
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 6px 14px;
    font-size: 12px;
    cursor: pointer;
    color: var(--text-dim);
  }
  .code-tab:first-child { border-radius: 6px 0 0 6px; }
  .code-tab:last-child { border-radius: 0 6px 6px 0; }
  .code-tab.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .code-block {
    background: var(--bg);
    border-radius: 6px;
    padding: 12px;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    font-size: 11px;
    line-height: 1.5;
    color: var(--text);
    white-space: pre-wrap;
    word-break: break-all;
    max-height: 200px;
    overflow-y: auto;
    cursor: text;
  }

  /* Error card */
  .error-card {
    background: rgba(198, 40, 40, 0.08);
    border: 1px solid rgba(239, 83, 80, 0.4);
    border-radius: 10px;
    padding: 14px 16px;
    color: #EF5350;
  }
  .error-card-title {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 6px;
  }
  .error-card-message {
    font-size: 12px;
    line-height: 1.5;
    color: #e09090;
  }
  .error-card-message code {
    background: rgba(239, 83, 80, 0.12);
    padding: 1px 5px;
    border-radius: 3px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
  }
  .error-card-message a {
    color: #fff;
    text-decoration: underline;
    text-decoration-color: rgba(255,255,255,0.4);
  }
  .error-card-message a:hover {
    text-decoration-color: #fff;
  }

  .font-info {
    font-size: 11px;
    color: var(--text-dim);
    margin-top: 6px;
  }
  .font-info a { color: var(--accent); text-decoration: none; }
  .font-info a:hover { text-decoration: underline; }

  /* Style toggles */
  .style-toggles {
    display: flex;
    gap: 4px;
    margin-top: 8px;
  }
  .style-toggle {
    width: 32px;
    height: 28px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 5px;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 13px;
    font-family: inherit;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.15s, color 0.15s, background 0.15s;
  }
  .style-toggle:hover { border-color: var(--accent); color: var(--text); }
  .style-toggle.active { border-color: var(--accent); background: rgba(124,138,255,0.15); color: var(--text); }
  .style-toggle-b { font-weight: 700; }
  .style-toggle-i { font-style: italic; }

  .slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .slider-row input[type="range"] {
    flex: 1;
    accent-color: var(--accent);
  }
  .slider-val {
    font-size: 11px;
    color: var(--text-dim);
    min-width: 30px;
    text-align: right;
    font-family: monospace;
  }

  .badge-drop-zone {
    border: 1.5px dashed var(--border);
    border-radius: 8px;
    padding: 14px 10px;
    text-align: center;
    color: var(--text-dim);
    font-size: 11px;
    cursor: pointer;
    transition: border-color 0.15s, background 0.15s;
    margin-top: 8px;
    outline: none;
    line-height: 1.5;
  }
  .badge-drop-zone:hover {
    border-color: var(--accent);
  }
  .badge-drop-zone:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(53,116,240,0.25);
  }
  .badge-drop-zone.dragover {
    border-color: var(--accent);
    background: rgba(53,116,240,0.08);
  }
  .badge-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-top: 8px;
  }
  .badge-list:empty { display: none; }
  .badge-list-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 5px 6px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 11px;
    cursor: pointer;
    transition: border-color 0.15s, background 0.15s;
    user-select: none;
  }
  .badge-list-item:hover {
    border-color: var(--accent);
  }
  .badge-list-item.selected {
    border-color: var(--accent);
    background: rgba(53,116,240,0.08);
  }
  .badge-list-item.drag-over {
    border-top: 2px solid var(--accent);
  }
  .badge-list-item .drag-handle {
    cursor: grab;
    color: var(--text-dim);
    font-size: 10px;
    line-height: 1;
    flex-shrink: 0;
    padding: 0 2px;
  }
  .badge-list-item .drag-handle:active { cursor: grabbing; }
  .badge-list-item svg { flex-shrink: 0; }
  .badge-list-item-name {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: var(--text);
  }
  .badge-list-item .badge-remove-btn {
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    padding: 2px;
    font-size: 14px;
    line-height: 1;
    flex-shrink: 0;
  }
  .badge-list-item .badge-remove-btn:hover { color: var(--error); }

  .anchor-grid {
    display: grid;
    grid-template-columns: repeat(3, 24px);
    gap: 3px;
    margin-top: 6px;
  }
  .anchor-cell {
    width: 24px;
    height: 24px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--surface2);
    cursor: pointer;
    position: relative;
    display: flex;
    align-items: var(--ay);
    justify-content: var(--ax);
    padding: 4px;
    transition: border-color 0.15s, background 0.15s;
  }
  .anchor-cell:hover {
    border-color: var(--accent);
  }
  .anchor-cell.active {
    border-color: var(--accent);
    background: rgba(53,116,240,0.15);
  }
  .anchor-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }
  .anchor-cell.active .anchor-dot {
    background: var(--accent);
  }

  .footer {
    max-width: 1400px;
    border-top: 1px solid var(--surface2);
    margin: 60px auto 0;
    padding-top: 32px;
    text-align: center;
    font-size: 11px;
    color: var(--text-dim);
  }
  .footer a {
    color: var(--text-dim);
    text-decoration: underline;
    text-decoration-color: rgba(144,144,176,0.4);
  }
  .footer a:hover { color: var(--text); text-decoration-color: var(--text); }
  .toggle-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 0;
  }
  .toggle-row input { display: none; }
  .toggle-switch {
    width: 32px;
    height: 18px;
    background: var(--border);
    border-radius: 9px;
    position: relative;
    transition: background 0.2s;
    flex-shrink: 0;
  }
  .toggle-switch::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background: var(--surface2);
    border-radius: 50%;
    transition: transform 0.2s;
  }
  .toggle-row input:checked + .toggle-switch {
    background: var(--accent);
  }
  .toggle-row input:checked + .toggle-switch::after {
    transform: translateX(14px);
  }

  .footer-how {
    max-width: 520px;
    margin: 0 auto 16px;
    line-height: 1.6;
  }
  .footer-how summary {
    cursor: pointer;
    list-style: none;
    text-decoration: underline;
    text-decoration-color: rgba(144,144,176,0.4);
    transition: color 0.15s, text-decoration-color 0.15s;
  }
  .footer-how summary:hover { color: var(--text); text-decoration-color: var(--text); }
  .footer-how summary::-webkit-details-marker { display: none; }
  .footer-how ol {
    margin-top: 8px;
    text-align: left;
    padding-left: 0;
    list-style-position: inside;
    display: inline-block;
  }
  .footer-how li { margin-bottom: 2px; }
  .footer-how .flowchart { margin-top: 14px; text-align: center; }
  .footer-how .flowchart svg { max-width: 100%; height: auto; }
  .logo-light { display: none; }
  .logo-dark { display: block; }
  [data-theme="islands-light"] .logo-light { display: block; }
  [data-theme="islands-light"] .logo-dark { display: none; }
  .header-logo { flex-shrink: 0; }
</style>
</head>
<body>

<div class="header">
  <div style="display:flex;align-items:center;gap:10px">
    <svg class="header-logo logo-light" width="32" height="32" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="6.5" fill="#E7EFFD" stroke="#3574F0"/><path fill="#3574F0" d="M7.16 4.28L7.16 11.72L6.03 11.72L6.03 4.28L7.16 4.28ZM9.33 4.40L9.33 4.40Q9.59 4.40 9.78 4.54Q9.97 4.67 9.97 5.01L9.97 5.01Q9.97 5.35 9.78 5.49Q9.59 5.63 9.33 5.63L9.33 5.63Q9.06 5.63 8.88 5.49Q8.70 5.35 8.70 5.01L8.70 5.01Q8.70 4.67 8.88 4.54Q9.06 4.40 9.33 4.40ZM8.76 6.43L9.89 6.43L9.89 11.72L8.76 11.72L8.76 6.43Z"/></svg>
    <svg class="header-logo logo-dark" width="32" height="32" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="6.5" fill="#25324D" stroke="#548AF7"/><path fill="#548AF7" d="M7.16 4.28L7.16 11.72L6.03 11.72L6.03 4.28L7.16 4.28ZM9.33 4.40L9.33 4.40Q9.59 4.40 9.78 4.54Q9.97 4.67 9.97 5.01L9.97 5.01Q9.97 5.35 9.78 5.49Q9.59 5.63 9.33 5.63L9.33 5.63Q9.06 5.63 8.88 5.49Q8.70 5.35 8.70 5.01L8.70 5.01Q8.70 4.67 8.88 4.54Q9.06 4.40 9.33 4.40ZM8.76 6.43L9.89 6.43L9.89 11.72L8.76 11.72L8.76 6.43Z"/></svg>
    <div>
    <h1>Letter Icon Composer</h1>
    <p class="subtitle">Custom IntelliJ-style letter icons for plugin developers</p>
    </div>
  </div>
  <div class="socials">
    <button class="style-toggle" id="themeToggle" title="Toggle site theme" style="width:auto;padding:0 8px;font-size:11px;gap:4px">
      <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 1a7 7 0 100 14A7 7 0 008 1zM2 8a6 6 0 0112 0A6 6 0 012 8zm6-4.5v9a4.5 4.5 0 000-9z"/></svg>
      <span id="themeLabel">Islands Dark</span>
    </button>
    <a href="https://github.com/DavidSeptimus/letter-icon-composer" target="_blank" title="GitHub">
      <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
    </a>
    <a href="https://linkedin.com/in/DavidSeptimus" target="_blank" title="LinkedIn">
      <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor"><path d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822 0-1.359.54-1.359 1.248 0 .694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016l.016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225h2.4z"/></svg>
    </a>
  </div>
</div>

<div class="layout">
  <!-- Controls Panel -->
  <div>
    <div class="panel">
      <details class="section" open>
        <summary class="section-title">Letter</summary>
        <input type="text" id="letter" class="letter-input" value="N" maxlength="2" placeholder="A">
        <div class="style-toggles">
          <button class="style-toggle style-toggle-b" data-style="bold" title="Bold">B</button>
          <button class="style-toggle style-toggle-i" data-style="italic" title="Italic">I</button>
        </div>
      </details>

      <details class="section" open>
        <summary class="section-title">Shape</summary>
        <div class="shape-grid" id="shapeGrid"></div>
      </details>

      <details class="section" open>
        <summary class="section-title">Badge</summary>
        <div id="badgeDropZone" class="badge-drop-zone" tabindex="0">
          Drop, paste, or <a href="#" id="badgeBrowseLink" style="color:var(--accent);text-decoration:none">browse</a> an SVG file
        </div>
        <input type="file" id="badgeFileInput" accept=".svg" style="display:none">
        <div class="badge-list" id="badgeList"></div>
        <div id="badgeTuning" style="display:none">
          <div style="display:flex;justify-content:space-between;align-items:start;margin-top:6px">
            <div>
              <label style="margin:0">Anchor</label>
              <div class="anchor-grid" id="anchorGrid"></div>
            </div>
            <button class="btn btn-secondary" id="resetModifierSliders" style="padding:2px 8px;font-size:10px">Reset</button>
          </div>
          <label style="margin-top:8px">Badge X Offset</label>
          <div class="slider-row">
            <input type="range" id="badgeXOffset" min="-4" max="4" step="0.1" value="0">
            <span class="slider-val" id="badgeXOffsetVal">0.0</span>
          </div>
          <label style="margin-top:8px">Badge Y Offset</label>
          <div class="slider-row">
            <input type="range" id="badgeYOffset" min="-4" max="4" step="0.1" value="0">
            <span class="slider-val" id="badgeYOffsetVal">0.0</span>
          </div>
          <label style="margin-top:8px">Badge Scale</label>
          <div class="slider-row">
            <input type="range" id="badgeScale" min="0.1" max="4.0" step="0.05" value="1">
            <span class="slider-val" id="badgeScaleVal">1.00</span>
          </div>
          <label style="margin-top:8px">Gap</label>
          <div class="slider-row">
            <input type="range" id="badgeGap" min="0" max="2" step="0.1" value="1">
            <span class="slider-val" id="badgeGapVal">1</span>
          </div>
        </div>
      </details>

      <details class="section" open>
        <summary class="section-title">Color Preset</summary>
        <div class="preset-grid" id="presetGrid"></div>
      </details>

    </div>
  </div>

  <!-- Preview Panel -->
  <div class="preview-area">
    <div class="preview-toggles">
      <button class="style-toggle" id="toggleCheckerboard" title="Checkerboard background">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M0 0h4v4H0zm4 4h4v4H4zm4-4h4v4H8zm4 4h4v4h-4zM0 8h4v4H0zm8 0h4v4H8zm-4 4h4v4H4zm8 0h4v4h-4z" opacity="0.6"/></svg>
      </button>
      <button class="style-toggle" id="togglePixelGrid" title="Pixel grid overlay">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1"><line x1="4" y1="0" x2="4" y2="16"/><line x1="8" y1="0" x2="8" y2="16"/><line x1="12" y1="0" x2="12" y2="16"/><line x1="0" y1="4" x2="16" y2="4"/><line x1="0" y1="8" x2="16" y2="8"/><line x1="0" y1="12" x2="16" y2="12"/></svg>
      </button>
      <div class="toggle-separator"></div>
      <button class="style-toggle" id="toggleGuideShape" title="Shape size guide">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="rgba(255,100,100,0.85)" stroke-width="1.2"><rect x="2" y="2" width="12" height="12" rx="1" stroke-dasharray="3 2"/></svg>
      </button>
      <button class="style-toggle" id="toggleGuideLetter" title="Letter size guide">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="rgba(100,200,255,0.85)" stroke="none"><text x="8" y="12.5" text-anchor="middle" font-size="12" font-weight="600" font-family="sans-serif">A</text></svg>
      </button>
      <button class="style-toggle" id="toggleGuideNotch" style="display:none" title="Gap size guide">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="rgba(255,180,50,0.85)" stroke-width="1.2"><path d="M10 14H14V10" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <button class="style-toggle" id="toggleGuideBadge" style="display:none" title="Badge size guide">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="rgba(130,220,100,0.85)" stroke-width="1.2"><rect x="8" y="8" width="6" height="6" rx="0.5"/></svg>
      </button>
    </div>

    <div class="preview-row">
      <div class="preview-card preview-light">
        <div class="preview-card-title">Light Theme</div>
        <div class="preview-canvas-wrap">
          <div>
            <div class="preview-zoomed" id="previewLightZoomed">
              <div class="pixel-grid" id="pixelGridLight"></div>
              <div class="size-guide size-guide-shape" id="guideShapeLight"></div>
              <div class="size-guide size-guide-letter" id="guideLetterLight"></div>
              <div class="size-guide size-guide-notch" id="guideNotchLight"></div>
              <div class="size-guide size-guide-badge" id="guideBadgeLight"></div>
            </div>
          </div>
          <div class="preview-actual">
            <div id="previewLightActual"></div>
            <span id="lightSizeLabel">16×16</span>
          </div>
        </div>
        <div class="btn-row">
          <button class="btn btn-secondary" id="copyLight">Copy SVG</button>
          <button class="btn" id="downloadLight">Download</button>
        </div>
      </div>
      <div class="preview-card preview-dark">
        <div class="preview-card-title">Dark Theme</div>
        <div class="preview-canvas-wrap">
          <div>
            <div class="preview-zoomed" id="previewDarkZoomed">
              <div class="pixel-grid" id="pixelGridDark"></div>
              <div class="size-guide size-guide-shape" id="guideShapeDark"></div>
              <div class="size-guide size-guide-letter" id="guideLetterDark"></div>
              <div class="size-guide size-guide-notch" id="guideNotchDark"></div>
              <div class="size-guide size-guide-badge" id="guideBadgeDark"></div>
            </div>
          </div>
          <div class="preview-actual">
            <div id="previewDarkActual"></div>
            <span id="darkSizeLabel">16×16</span>
          </div>
        </div>
        <div class="btn-row">
          <button class="btn btn-secondary" id="copyDark">Copy SVG</button>
          <button class="btn" id="downloadDark">Download</button>
        </div>
      </div>
    </div>

    <div class="btn-row" style="padding: 8px 0;">
      <button class="btn" id="downloadBoth">Download Both (Light + Dark)</button>
    </div>

    <div class="code-panel">
      <div class="code-header">
        <div class="code-tabs">
          <button class="code-tab active" data-tab="light" id="tabLight">Light SVG</button>
          <button class="code-tab" data-tab="dark" id="tabDark">Dark SVG</button>
        </div>
        <span class="file-size" id="fileSize"></span>
      </div>
      <div class="code-block" id="codeBlock" onclick="window.getSelection().selectAllChildren(this)"></div>
    </div>

    <div class="error-card" id="errorCard" style="display:none">
      <div class="error-card-title">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM7.25 5h1.5v4h-1.5V5zm.75 6.5a.75.75 0 110-1.5.75.75 0 010 1.5z" fill="currentColor"/></svg>
        Error
      </div>
      <div class="error-card-message" id="errorMessage"></div>
    </div>
  </div>

  <!-- Right Panel -->
  <div>
    <div class="panel">
      <details class="section" open>
        <summary class="section-title">Font</summary>
        <select id="fontSelect">
          <option value="open-sans" selected>Open Sans (JetBrains recommended)</option>
          <option value="arial">Arial</option>
          <option value="inter">Inter</option>
          <option value="google-fonts">Google Fonts...</option>
          <option value="custom">Import custom .ttf/.otf</option>
        </select>
        <div id="googleFontsRow" style="display:none; margin-top:8px;">
          <div style="display:flex; gap:6px;">
            <input type="text" id="googleFontName" placeholder="e.g. Roboto, Fira Sans" style="flex:1">
            <select id="googleFontWeight" style="width:90px">
              <option value="400">Regular</option>
              <option value="500">Medium</option>
              <option value="600" selected>SemiBold</option>
              <option value="700">Bold</option>
            </select>
            <button class="btn" id="googleFontLoad" style="padding:6px 10px; white-space:nowrap">Load</button>
          </div>
          <div id="googleFontStatus" class="font-info" style="margin-top:4px"></div>
        </div>
        <input type="file" id="fontFile" accept=".ttf,.otf,.woff" style="display:none">
        <div class="font-info">
          JetBrains recommends <b>Arial</b> or <b>Open Sans</b> for icon letters.
          <a href="https://plugins.jetbrains.com/docs/intellij/icons-style.html" target="_blank">Guidelines</a>
        </div>
      </details>

      <details class="section" open>
        <summary class="section-title">Light Theme Colors</summary>
        <div class="color-row">
          <div>
            <label>Fill</label>
            <div class="color-field">
              <input type="color" id="lightFill" value="#E7EFFD">
              <input type="text" id="lightFillHex" value="#E7EFFD">
            </div>
          </div>
          <div>
            <label>Stroke / Letter</label>
            <div class="color-field">
              <input type="color" id="lightStroke" value="#3574F0">
              <input type="text" id="lightStrokeHex" value="#3574F0">
            </div>
          </div>
        </div>
      </details>

      <details class="section" open>
        <summary class="section-title">Dark Theme Colors</summary>
        <div class="color-row">
          <div>
            <label>Fill</label>
            <div class="color-field">
              <input type="color" id="darkFill" value="#25324D">
              <input type="text" id="darkFillHex" value="#25324D">
            </div>
          </div>
          <div>
            <label>Stroke / Letter</label>
            <div class="color-field">
              <input type="color" id="darkStroke" value="#548AF7">
              <input type="text" id="darkStrokeHex" value="#548AF7">
            </div>
          </div>
        </div>
      </details>

      <details class="section" open>
        <summary class="section-title" style="justify-content:space-between">
          <span>Fine Tuning</span>
          <button class="btn btn-secondary" id="resetSliders" style="padding:2px 8px;font-size:10px;text-transform:none;letter-spacing:0">Reset</button>
        </summary>
        <label>Shape Scale</label>
        <div class="slider-row">
          <input type="range" id="shapeScale" min="0.6" max="1.4" step="0.05" value="1">
          <span class="slider-val" id="shapeScaleVal">1.00</span>
        </div>
        <label style="margin-top:8px">Font Size</label>
        <div class="slider-row">
          <input type="range" id="fontSize" min="4" max="14" step="0.1" value="7">
          <span class="slider-val" id="fontSizeVal">7.0</span>
        </div>
        <label style="margin-top:8px">Vertical Offset</label>
        <div class="slider-row">
          <input type="range" id="yOffset" min="-2" max="2" step="0.1" value="0">
          <span class="slider-val" id="yOffsetVal">0.0</span>
        </div>
        <label style="margin-top:8px">Horizontal Offset</label>
        <div class="slider-row">
          <input type="range" id="xOffset" min="-2" max="2" step="0.1" value="0">
          <span class="slider-val" id="xOffsetVal">0.0</span>
        </div>
        <label style="margin-top:8px">Stroke Width</label>
        <div class="slider-row">
          <input type="range" id="strokeWidth" min="0.5" max="2" step="0.1" value="1">
          <span class="slider-val" id="strokeWidthVal">1.0</span>
        </div>
      </details>

      <details class="section" open>
        <summary class="section-title">File Name</summary>
        <input type="text" id="fileName" value="icon" placeholder="e.g. myNode">
        <div class="font-info" style="margin-top:4px">
          Downloads as <code>{name}.svg</code> and <code>{name}_dark.svg</code>
        </div>
      </details>

      <div class="section" style="margin-top:20px">
        <label class="toggle-row">
          <span>Optimize with SVGO</span>
          <input type="checkbox" id="toggleOptimize" checked>
          <span class="toggle-switch"></span>
        </label>
      </div>
    </div>
  </div>
</div>

<footer class="footer">
  <details class="footer-how">
    <summary>How it works</summary>
    <ol>
      <li><a href="https://opentype.js.org" target="_blank">opentype.js</a> converts font glyphs into SVG path data</li>
      <li>The path is composited onto a background shape</li>
      <li>If a badge SVG is provided, <a href="http://paperjs.org" target="_blank">Paper.js</a> builds the badge silhouette (expanding strokes into filled outlines via <a href="https://github.com/nicholaschiang/paperjs-offset" target="_blank">paperjs-offset</a>), offsets it by a configurable gap, and boolean-subtracts it from each background shape; the badge is then overlaid in the cleared area</li>
      <li><a href="https://svgo.dev" target="_blank">SVGO</a> optimizes the final SVG</li>
    </ol>
    <div class="flowchart">
      <svg viewBox="-2 -1 750 106" width="750" height="106" xmlns="http://www.w3.org/2000/svg">
        <style>
          .fc-node { stroke-width: 1.2; }
          .fc-label { font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; font-size: 10px; fill: var(--text); text-anchor: middle; dominant-baseline: central; }
          .fc-arrow { stroke: var(--accent); stroke-width: 1.5; fill: none; stroke-dasharray: 6 4; animation: fc-flow 0.8s linear infinite; }
          .fc-head { fill: var(--accent); }
          .fc-branch { font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; font-size: 8px; fill: var(--text-dim); }
          @keyframes fc-flow { to { stroke-dashoffset: -10; } }
        </style>
        <!-- Font File (rounded rect) -->
        <rect x="1" y="8" width="72" height="32" rx="8" ry="8" class="fc-node" fill="var(--surface2)" stroke="var(--border)"/>
        <text x="37" y="24" class="fc-label">Font File</text>
        <!-- Arrow 1 -->
        <line x1="77" y1="24" x2="103" y2="24" class="fc-arrow"/>
        <polygon points="103,20 111,24 103,28" class="fc-head"/>
        <!-- opentype.js (stadium) -->
        <rect x="113" y="8" width="80" height="32" rx="16" ry="16" class="fc-node" fill="var(--surface2)" stroke="var(--accent)"/>
        <text x="153" y="24" class="fc-label" fill="var(--accent)">opentype.js</text>
        <!-- Arrow 2 -->
        <line x1="197" y1="24" x2="223" y2="24" class="fc-arrow"/>
        <polygon points="223,20 231,24 223,28" class="fc-head"/>
        <!-- SVG Path (parallelogram) -->
        <polygon points="239,8 305,8 297,40 231,40" class="fc-node" fill="var(--surface2)" stroke="var(--border)"/>
        <text x="268" y="24" class="fc-label">SVG Path</text>
        <!-- Arrow 3 -->
        <line x1="309" y1="24" x2="327" y2="24" class="fc-arrow"/>
        <polygon points="327,20 335,24 327,28" class="fc-head"/>
        <!-- Compose (diamond) -->
        <polygon points="371,4 407,24 371,44 335,24" class="fc-node" fill="var(--surface2)" stroke="var(--border)"/>
        <text x="371" y="24" class="fc-label" font-size="9">Compose</text>
        <!-- Arrow 4 -->
        <line x1="407" y1="24" x2="433" y2="24" class="fc-arrow"/>
        <polygon points="433,20 441,24 433,28" class="fc-head"/>
        <!-- Badge? (diamond) -->
        <polygon points="471,4 507,24 471,44 435,24" class="fc-node" fill="var(--surface2)" stroke="var(--border)"/>
        <text x="471" y="24" class="fc-label" font-size="9">Badge?</text>
        <!-- "no" branch: straight to SVGO -->
        <line x1="507" y1="24" x2="617" y2="24" class="fc-arrow"/>
        <text x="520" y="17" class="fc-branch">no</text>
        <polygon points="617,20 625,24 617,28" class="fc-head"/>
        <!-- "yes" branch: down to Badge SVG row -->
        <line x1="471" y1="44" x2="471" y2="62" class="fc-arrow"/>
        <text x="480" y="54" class="fc-branch">yes</text>
        <polygon points="467,62 471,70 475,62" class="fc-head"/>
        <!-- Badge SVG (parallelogram) -->
        <polygon points="443,72 517,72 509,96 435,96" class="fc-node" fill="var(--surface2)" stroke="var(--border)"/>
        <text x="476" y="84" class="fc-label" font-size="9">Badge SVG</text>
        <!-- Arrow from Badge SVG to Cut + Overlay -->
        <line x1="521" y1="84" x2="539" y2="84" class="fc-arrow"/>
        <polygon points="539,80 547,84 539,88" class="fc-head"/>
        <!-- Cut + Overlay (stadium) -->
        <rect x="549" y="68" width="80" height="32" rx="16" ry="16" class="fc-node" fill="var(--surface2)" stroke="var(--accent)"/>
        <text x="589" y="84" class="fc-label" fill="var(--accent)" font-size="9">Cut + Overlay</text>
        <!-- Arrow from Cut + Overlay up to join main line before SVGO -->
        <line x1="633" y1="84" x2="653" y2="84" class="fc-arrow"/>
        <line x1="653" y1="84" x2="653" y2="46" class="fc-arrow"/>
        <polygon points="649,46 653,40 657,46" class="fc-head"/>
        <!-- SVGO (stadium) — shifted right -->
        <rect x="625" y="8" width="56" height="32" rx="16" ry="16" class="fc-node" fill="var(--surface2)" stroke="var(--accent)"/>
        <text x="653" y="24" class="fc-label" fill="var(--accent)">SVGO</text>
        <!-- Arrow 6 -->
        <line x1="685" y1="24" x2="701" y2="24" class="fc-arrow"/>
        <polygon points="701,20 709,24 701,28" class="fc-head"/>
        <!-- Icon (circle) -->
        <circle cx="727" cy="24" r="18" class="fc-node" fill="var(--surface2)" stroke="var(--accent)"/>
        <text x="727" y="24" class="fc-label" fill="var(--accent)" font-weight="600">Icon</text>
      </svg>
    </div>
  </details>
  Powered by <a href="https://opentype.js.org" target="_blank">opentype.js</a>,
  <a href="http://paperjs.org" target="_blank">Paper.js</a>,
  <a href="https://github.com/nicholaschiang/paperjs-offset" target="_blank">paperjs-offset</a>,
  and <a href="https://svgo.dev" target="_blank">SVGO</a>
  &middot; Licensed under <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache 2.0</a>
  &middot; This site is not affiliated with JetBrains s.r.o.
</footer>

<script type="module">
import { optimize as svgoOptimize } from 'https://cdn.jsdelivr.net/npm/svgo@3/dist/svgo.browser.js';
import {
  PRESETS,
  SHAPES,
  getFontUrl,
  getGoogleFontUrl,
  calibrateFontSize as calibrateFontSizeCore,
  boundFontSizeToShape as boundFontSizeToShapeCore,
  generateSVG as generateSVGCore,
} from './core.js';
import { createModifierEngine, computeBadgePlacement, ANCHOR_POINTS } from './modifier.js';

// ── State ─────────────────────────────────────────────────────────────
let currentFont = null;

let currentShape = 'circle';
let activeTab = 'light';
let badges = [];           // Array of { id, svgText, name, anchor, xOff, yOff, scale, gap }
let nextBadgeId = 1;
let selectedBadgeId = null;
let svgLight = '';
let svgDark = '';
let styles = { bold: false, italic: false };
let svgoEnabled = localStorage.getItem('svgo-enabled') !== 'false';

// ── SVG Optimization ──────────────────────────────────────────────────
const svgoConfig = {
  multipass: true,
  plugins: [
    {
      name: 'preset-default',
      params: {
        overrides: {
          inlineStyles: false,
          removeViewBox: false,
          cleanupEnableBackground: false,
          removeHiddenElems: false,
          convertShapeToPath: false,
          moveElemsAttrsToGroup: false,
          moveGroupAttrsToElems: false,
          convertPathData: false,
        },
      },
    },
    'convertStyleToAttrs',
    'cleanupListOfValues',
    'sortAttrs',
  ],
};

function optimizeSVG(svgString) {
  if (!svgoEnabled) return svgString;
  try {
    return svgoOptimize(svgString, svgoConfig).data;
  } catch {
    return svgString;
  }
}

// ── Paper.js Modifier Engine ──────────────────────────────────────────
const { applyModifier } = await createModifierEngine(
  typeof paper !== 'undefined' ? paper : null);

// ── Error Reporting ───────────────────────────────────────────────────
function showError(message) {
  const card = document.getElementById('errorCard');
  document.getElementById('errorMessage').innerHTML = message;
  card.style.display = 'block';
}

function clearError() {
  document.getElementById('errorCard').style.display = 'none';
}

// ── Font Loading ──────────────────────────────────────────────────────
let currentFontKey = 'open-sans';

function calibrateFontSize() {
  if (!currentFont) return;
  const letter = document.getElementById('letter').value;
  const targetHeight = SHAPES[currentShape]?.targetHeight ?? 7.0;
  const calibrated = calibrateFontSizeCore(currentFont, letter, targetHeight);
  const sw = parseFloat(document.getElementById('strokeWidth').value);
  const xOff = parseFloat(document.getElementById('xOffset').value);
  const yOff = parseFloat(document.getElementById('yOffset').value);
  const sc = parseFloat(document.getElementById('shapeScale').value);
  const bounded = boundFontSizeToShapeCore(currentFont, letter, calibrated, currentShape, sw, xOff, yOff, sc);
  document.getElementById('fontSize').value = bounded;
  document.getElementById('fontSizeVal').textContent = bounded.toFixed(1);
}

function saveFontSetting() {
  const setting = { key: currentFontKey };
  if (currentFontKey === 'google-fonts') {
    setting.name = document.getElementById('googleFontName').value;
    setting.weight = document.getElementById('googleFontWeight').value;
  }
  localStorage.setItem('font-setting', JSON.stringify(setting));
}

async function loadFont(key) {
  currentFontKey = key;
  if (key === 'arial') {
    await loadSystemFont('Arial');
    return;
  }
  if (key === 'google-fonts' || key === 'custom') return;

  const url = getFontUrl(key, styles.bold, styles.italic);
  if (!url) {
    const label = document.querySelector(`#fontSelect option[value="${key}"]`)?.textContent || key;
    showError(`<b>${label}</b> does not have an italic variant.`);
    return;
  }
  try {
    currentFont = await opentype.load(url);
    calibrateFontSize();
    clearError();
    saveFontSetting();
    render();
  } catch (e) {
    console.error('Failed to load font:', e);
    const sig = e.message || '';
    if (sig.includes('Unsupported OpenType signature')) {
      const match = sig.match(/signature\s+(\w+)/);
      const tag = match ? match[1] : 'unknown';
      showError(`Font format not supported by opentype.js. Signature: <code>${tag}</code><br>This usually means the font uses COLRv1 color tables or WOFF2 compression. Try a different version or format (.otf, .ttf, .woff).`);
    } else {
      showError(`Failed to load font: <code>${sig}</code>`);
    }
  }
}

async function loadSystemFont(family) {
  if ('queryLocalFonts' in window) {
    try {
      const fonts = await window.queryLocalFonts();
      const wantBold = styles.bold;
      const wantItalic = styles.italic;
      const match = fonts.find(f => {
        if (f.family !== family) return false;
        const s = (f.style || f.fullName || '').toLowerCase();
        const isBold = /bold/i.test(s);
        const isItalic = /italic/i.test(s);
        return isBold === wantBold && isItalic === wantItalic;
      }) || fonts.find(f => {
        // Fallback: prefer regular (non-italic, non-bold) variant
        if (f.family !== family) return false;
        const s = (f.style || f.fullName || '').toLowerCase();
        return !(/bold/i.test(s)) && !(/italic/i.test(s));
      }) || fonts.find(f => f.family === family);
      if (match) {
        const blob = await match.blob();
        const buf = await blob.arrayBuffer();
        currentFont = opentype.parse(buf);
        calibrateFontSize();
        clearError();
        saveFontSetting();
        render();
        return;
      }
      showError(`"${family}" was not found on your system. Try <b>Arimo</b> via the Google Fonts option — it's a metric-compatible open-source alternative.`);
    } catch (e) {
      showError(`Local font access was denied. Try <b>Arimo</b> via the Google Fonts option — it's a metric-compatible open-source alternative to ${family}.`);
    }
  } else {
    showError(`Your browser doesn't support local font access. Try <b>Arimo</b> via the Google Fonts option — it's a metric-compatible open-source alternative to ${family}.`);
  }
}

// ── SVG Generation (delegates to core.js) ─────────────────────────────
let lastViewBoxSize = 16;

function generateSVG(fill, stroke, letterColor, strokeWidth) {
  const letter = document.getElementById('letter').value;
  const fontSize = parseFloat(document.getElementById('fontSize').value);
  const xOff = parseFloat(document.getElementById('xOffset').value);
  const yOff = parseFloat(document.getElementById('yOffset').value);
  const shapeScale = parseFloat(document.getElementById('shapeScale').value);

  const { svg, error, viewBoxSize } = generateSVGCore({
    font: currentFont,
    letter,
    shape: currentShape,
    fill,
    stroke,
    letterColor,
    strokeWidth,
    fontSize,
    xOffset: xOff,
    yOffset: yOff,
    shapeScale,
  });

  lastViewBoxSize = viewBoxSize;
  if (error) showError(error);
  return svg;
}

// ── Preview Helpers ───────────────────────────────────────────────────
function setZoomedSvg(containerId, svgMarkup) {
  const container = document.getElementById(containerId);
  const existing = container.querySelector('svg');
  if (existing) existing.remove();
  container.insertAdjacentHTML('afterbegin', svgMarkup);
}

function drawPixelGrids() {
  drawPixelGrid('pixelGridLight');
  drawPixelGrid('pixelGridDark');
}

function drawPixelGrid(id) {
  const el = document.getElementById(id);
  if (!el) return;
  const s = lastViewBoxSize;
  const sw = 1 / 8;
  let lines = '';
  for (let i = 1; i < s; i++) {
    lines += `<line x1="${i}" y1="0" x2="${i}" y2="${s}"/>`;
    lines += `<line x1="0" y1="${i}" x2="${s}" y2="${i}"/>`;
  }
  el.innerHTML = `<svg viewBox="0 0 ${s} ${s}" width="128" height="128" shape-rendering="crispEdges">` +
    `<g fill="none" stroke="rgba(200,200,200,0.25)" stroke-width="${sw}">${lines}</g></svg>`;
}

// ── Size Guide Overlays ───────────────────────────────────────────────
const GUIDE_COLORS = {
  shape:  'rgba(255,100,100,0.85)',
  letter: 'rgba(100,200,255,0.85)',
  notch:  'rgba(255,180,50,0.85)',
  badge:  'rgba(130,220,100,0.85)',
};

function drawBracketGuide(x, y, w, h, label, color, viewBoxSize) {
  const s = viewBoxSize;
  const pad = 0.4;          // outset from bounding box
  const arm = Math.min(1.2, Math.min(w, h) / 3);  // bracket arm length
  const sw = 0.25;          // stroke width in viewBox units
  const bx = x - pad, by = y - pad, bw = w + pad * 2, bh = h + pad * 2;

  // Four L-shaped corner brackets (outset)
  const brackets = [
    // top-left
    `M${bx},${by + arm} L${bx},${by} L${bx + arm},${by}`,
    // top-right
    `M${bx + bw - arm},${by} L${bx + bw},${by} L${bx + bw},${by + arm}`,
    // bottom-right
    `M${bx + bw},${by + bh - arm} L${bx + bw},${by + bh} L${bx + bw - arm},${by + bh}`,
    // bottom-left
    `M${bx + arm},${by + bh} L${bx},${by + bh} L${bx},${by + bh - arm}`,
  ];

  // Label: "W×H" centered above top edge, or below if clipping
  const wLabel = Math.round(w * 10) / 10;
  const hLabel = Math.round(h * 10) / 10;
  const text = `${wLabel}\u00d7${hLabel}`;
  const fontSize = 1.1;
  let labelY = by - 0.5;
  let anchor = 'auto';
  if (labelY < fontSize + 0.3) {
    // Would clip — place inside top of box
    labelY = by + fontSize + 0.3;
  }
  const labelX = bx + bw / 2;

  return `<svg viewBox="0 0 ${s} ${s}" width="128" height="128" xmlns="http://www.w3.org/2000/svg">` +
    `<g fill="none" stroke="${color}" stroke-width="${sw}" stroke-linecap="round" stroke-linejoin="round">` +
    brackets.map(d => `<path d="${d}"/>`).join('') +
    `</g>` +
    `<text x="${labelX}" y="${labelY}" fill="${color}" font-size="${fontSize}" font-family="sans-serif" font-weight="600" text-anchor="middle" dominant-baseline="${anchor}">${text}</text>` +
    `</svg>`;
}

function computeShapeBounds(shapeName, strokeWidth, shapeScale) {
  const shapeDef = SHAPES[shapeName];
  if (!shapeDef) return null;

  const baseVB = shapeDef.viewBoxSize ?? 16;
  const nc = baseVB / 2;
  const sc = shapeScale;
  const sw = strokeWidth;
  const s = lastViewBoxSize;
  const center = s / 2;

  // Compute visual bounding box in native (pre-scale) coordinates
  let nx, ny, nw, nh;

  if (shapeName === 'circle') {
    // circle at (nc,nc), r = nc-1-sw/2, visual outer edge = r+sw/2 = nc-1
    const ext = nc - 1;
    nx = nc - ext; ny = nc - ext;
    nw = 2 * ext; nh = 2 * ext;
  } else if (shapeName === 'roundrect') {
    // rect at inset=1.5+sw/2, visual outer edge at 1.5 from viewBox edge
    nx = 1.5; ny = 1.5;
    nw = baseVB - 3; nh = baseVB - 3;
  } else if (shapeName === 'diamond' || shapeName === 'rounded-diamond') {
    // rotated 45deg rect; tips at nc ± (nc-1-sw/2), visual extent ± sw/2 more = nc ± (nc-1)
    const ext = nc - 1;
    nx = nc - ext; ny = nc - ext;
    nw = 2 * ext; nh = 2 * ext;
  } else if (shapeName === 'shield') {
    // hardcoded path: x 2.5..13.5, y ~1.54..~15.40, plus stroke
    nx = 2.5 - sw / 2; ny = 1.54 - sw / 2;
    nw = 11 + sw; nh = 13.86 + sw;
  } else if (shapeName === 'dashed-circle') {
    // fill circle ≈ center 8, radius ~7; dashed strokes are filled paths (no additional stroke)
    nx = 1; ny = 1; nw = 14; nh = 14;
  } else if (shapeName === 'dashed-rect') {
    // fill rect from (2,2) to (14,14); dashed strokes are filled paths
    nx = 2; ny = 2; nw = 12; nh = 12;
  } else if (shapeName === 'composite') {
    // back flap (5,2)→(13,10) + front rect (2,5)→(11,14), both with stroke
    nx = 2 - sw / 2; ny = 2 - sw / 2;
    nw = 11 + sw; nh = 12 + sw;
  } else if (shapeName === 'hexagon') {
    // path: M8 2.5 L13 5 v6 L8 13.5 L3 11 v-6 Z, with stroke
    nx = 3 - sw / 2; ny = 2.5 - sw / 2;
    nw = 10 + sw; nh = 11 + sw;
  } else if (shapeName === 'document') {
    // main path x 2.75..13.25, y 2.25..13.75, with stroke
    nx = 2.75 - sw / 2; ny = 2.25 - sw / 2;
    nw = 10.5 + sw; nh = 11.5 + sw;
  } else {
    return null;
  }

  // Apply scale transform: translate(center) scale(sc) translate(-nc)
  if (sc !== 1.0) {
    const x1 = center + sc * (nx - nc);
    const y1 = center + sc * (ny - nc);
    const x2 = center + sc * (nx + nw - nc);
    const y2 = center + sc * (ny + nh - nc);
    return { x: x1, y: y1, w: x2 - x1, h: y2 - y1 };
  }

  return { x: nx, y: ny, w: nw, h: nh };
}

function computeGuideBounds() {
  const s = lastViewBoxSize;
  const bounds = { shape: null, letter: null, notch: null, badge: null };

  // ── Shape bounds: analytical computation from shape geometry
  const sw = parseFloat(document.getElementById('strokeWidth').value);
  const sc = parseFloat(document.getElementById('shapeScale').value);
  bounds.shape = computeShapeBounds(currentShape, sw, sc);

  // ── Letter bounds: compute from font metrics
  if (currentFont) {
    const letter = document.getElementById('letter').value;
    const fontSize = parseFloat(document.getElementById('fontSize').value);
    const xOff = parseFloat(document.getElementById('xOffset').value);
    const yOff = parseFloat(document.getElementById('yOffset').value);
    const shapeDef = SHAPES[currentShape];
    const xAdj = xOff + (shapeDef?.defaultXOffset ?? 0);
    const yAdj = yOff + (shapeDef?.defaultYOffset ?? 0);
    const center = s / 2;

    if (letter) {
      try {
        const path = currentFont.getPath(letter, 0, 0, fontSize);
        const bb = path.getBoundingBox();
        const pw = bb.x2 - bb.x1;
        const ph = bb.y2 - bb.y1;
        if (pw > 0 && ph > 0) {
          const tx = center + xAdj - pw / 2;
          const ty = center + yAdj - ph / 2;
          bounds.letter = { x: tx, y: ty, w: pw, h: ph };
        }
      } catch { /* ignore */ }
    }
  }

  // ── Badge + gap bounds via computeBadgePlacement (selected badge only)
  const selBadge = badges.find(b => b.id === selectedBadgeId);
  if (selBadge) {
    const p = computeBadgePlacement(selBadge.svgText, s, selBadge.xOff, selBadge.yOff, selBadge.scale, selBadge.anchor);
    const finalW = p.badgeW * p.scale;
    const finalH = p.badgeH * p.scale;
    const bx = p.tx + p.minX * p.scale;
    const by = p.ty + p.minY * p.scale;
    const gap = selBadge.gap;

    // Badge bounds
    bounds.badge = { x: bx, y: by, w: finalW, h: finalH };

    // Gap/notch bounds = badge bbox inflated by gap
    bounds.notch = { x: bx - gap, y: by - gap, w: finalW + gap * 2, h: finalH + gap * 2 };
  }

  return bounds;
}

function drawSizeGuides() {
  const s = lastViewBoxSize;
  const bounds = computeGuideBounds();

  const types = ['shape', 'letter', 'notch', 'badge'];
  const variants = ['Light', 'Dark'];

  for (const type of types) {
    const b = bounds[type];
    for (const v of variants) {
      const el = document.getElementById(`guide${type.charAt(0).toUpperCase() + type.slice(1)}${v}`);
      if (!el) continue;
      if (b) {
        el.innerHTML = drawBracketGuide(b.x, b.y, b.w, b.h, '', GUIDE_COLORS[type], s);
      } else {
        el.innerHTML = '';
      }
    }
  }

  // Show/hide notch+badge toggle buttons based on badge presence
  const hasBadge = badges.length > 0;
  document.getElementById('toggleGuideNotch').style.display = hasBadge ? '' : 'none';
  document.getElementById('toggleGuideBadge').style.display = hasBadge ? '' : 'none';

  // If badge was removed while guides were active, remove the classes
  if (!hasBadge) {
    document.querySelectorAll('.preview-zoomed').forEach(el => {
      el.classList.remove('show-guide-notch', 'show-guide-badge');
    });
    document.getElementById('toggleGuideNotch').classList.remove('active');
    document.getElementById('toggleGuideBadge').classList.remove('active');
  }
}

// ── Render & Preview ──────────────────────────────────────────────────
function render() {
  clearError();
  const lightFill = document.getElementById('lightFill').value;
  const lightStroke = document.getElementById('lightStroke').value;
  const darkFill = document.getElementById('darkFill').value;
  const darkStroke = document.getElementById('darkStroke').value;
  const sw = parseFloat(document.getElementById('strokeWidth').value);

  let rawLight = generateSVG(lightFill, lightStroke, lightStroke, sw);
  let rawDark = generateSVG(darkFill, darkStroke, darkStroke, sw);

  if (badges.length > 0) {
    const opts = {
      badges: badges.map(b => ({
        svgText: b.svgText,
        xOffset: b.xOff, yOffset: b.yOff,
        scale: b.scale, gap: b.gap, anchor: b.anchor,
      })),
    };
    rawLight = applyModifier(rawLight, 'custom', lightStroke, lastViewBoxSize, opts);
    rawDark = applyModifier(rawDark, 'custom', darkStroke, lastViewBoxSize, opts);
  }

  svgLight = optimizeSVG(rawLight);
  svgDark = optimizeSVG(rawDark);

  // Zoomed previews (128x128) — use regex to handle any viewBox size
  const zoomRe = /width="\d+" height="\d+"/;
  const lightZoomed = svgLight.replace(zoomRe, 'width="128" height="128"');
  const darkZoomed = svgDark.replace(zoomRe, 'width="128" height="128"');

  setZoomedSvg('previewLightZoomed', lightZoomed);
  setZoomedSvg('previewDarkZoomed', darkZoomed);
  drawPixelGrids();

  // Sync checkerboard cell size with icon pixel size
  const cellSize = (128 / lastViewBoxSize / 2) + 'px';
  document.querySelectorAll('.preview-zoomed').forEach(el => el.style.setProperty('--cell', cellSize));

  // Actual size previews
  document.getElementById('previewLightActual').innerHTML = svgLight;
  document.getElementById('previewDarkActual').innerHTML = svgDark;

  // Update size labels
  const sizeText = `${lastViewBoxSize}\u00d7${lastViewBoxSize}`;
  document.getElementById('lightSizeLabel').textContent = sizeText;
  document.getElementById('darkSizeLabel').textContent = sizeText;

  // Size guides
  drawSizeGuides();

  // Code block
  updateCodeBlock();
}

function updateCodeBlock() {
  const code = activeTab === 'light' ? svgLight : svgDark;
  document.getElementById('codeBlock').textContent = code;
  document.getElementById('fileSize').textContent = new Blob([code]).size + ' B';
}

function switchTab(tab) {
  activeTab = tab;
  document.querySelectorAll('.code-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  updateCodeBlock();
}

// ── Download ──────────────────────────────────────────────────────────
function downloadFile(content, filename) {
  const blob = new Blob([content], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function downloadSVG(variant) {
  const name = document.getElementById('fileName').value || 'icon';
  const suffix = variant === 'dark' ? '_dark' : '';
  downloadFile(variant === 'light' ? svgLight : svgDark, `${name}${suffix}.svg`);
}

function downloadBoth() {
  downloadSVG('light');
  setTimeout(() => downloadSVG('dark'), 200);
}

function copySVG(variant, btn) {
  const svg = variant === 'light' ? svgLight : svgDark;
  navigator.clipboard.writeText(svg).then(() => {
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy SVG', 1200);
  });
}

// ── Color Sync ────────────────────────────────────────────────────────
function deselectPreset() {
  document.getElementById('presetGrid').querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
}

function parseHexColor(value) {
  let v = value.trim();
  if (!v.startsWith('#')) v = '#' + v;
  if (/^#[0-9a-fA-F]{3}$/.test(v)) {
    v = '#' + v[1] + v[1] + v[2] + v[2] + v[3] + v[3];
  }
  if (/^#[0-9a-fA-F]{6}$/.test(v)) return v.toUpperCase();
  return null;
}

function syncColor(pickerId, hexId) {
  const picker = document.getElementById(pickerId);
  const hex = document.getElementById(hexId);
  let fromPicker = false;

  picker.addEventListener('input', () => {
    fromPicker = true;
    hex.value = picker.value.toUpperCase();
    hex.classList.remove('invalid');
    render();
    fromPicker = false;
  });
  hex.addEventListener('input', () => {
    if (fromPicker) return;
    deselectPreset();
    const color = parseHexColor(hex.value);
    hex.classList.toggle('invalid', !color && hex.value.trim() !== '');
    if (color) {
      picker.value = color;
      render();
    }
  });
  hex.addEventListener('change', () => {
    if (fromPicker) return;
    deselectPreset();
    const color = parseHexColor(hex.value);
    if (color) {
      hex.value = color;
      hex.classList.remove('invalid');
      picker.value = color;
      render();
    } else {
      hex.classList.add('invalid');
    }
  });
}

// ── Presets ────────────────────────────────────────────────────────────
function buildPresets() {
  const grid = document.getElementById('presetGrid');
  let addedDivider = false;
  PRESETS.forEach((p, i) => {
    if (!p.official && !addedDivider) {
      addedDivider = true;
      const divider = document.createElement('div');
      divider.className = 'preset-divider';
      divider.textContent = 'Custom';
      grid.appendChild(divider);
    }
    const btn = document.createElement('button');
    btn.className = 'preset-btn' + (i === 0 ? ' active' : '');
    btn.innerHTML = `<span class="preset-swatch" data-light-fill="${p.lightFill}" data-light-stroke="${p.lightStroke}" data-dark-fill="${p.darkFill}" data-dark-stroke="${p.darkStroke}"></span>${p.name}`;
    btn.title = p.official ? `JetBrains expUI — ${p.name}` : `Custom — ${p.name}`;
    btn.addEventListener('click', () => {
      grid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('lightFill').value = p.lightFill;
      document.getElementById('lightFillHex').value = p.lightFill;
      document.getElementById('lightStroke').value = p.lightStroke;
      document.getElementById('lightStrokeHex').value = p.lightStroke;
      document.getElementById('darkFill').value = p.darkFill;
      document.getElementById('darkFillHex').value = p.darkFill;
      document.getElementById('darkStroke').value = p.darkStroke;
      document.getElementById('darkStrokeHex').value = p.darkStroke;
      render();
    });
    grid.appendChild(btn);
  });
}

// ── Shape Selection ───────────────────────────────────────────────────
function buildShapes() {
  const grid = document.getElementById('shapeGrid');
  const entries = Object.entries(SHAPES);
  let addedDivider = false;
  entries.forEach(([key, shape], i) => {
    if (!shape.official && !addedDivider) {
      addedDivider = true;
      const divider = document.createElement('div');
      divider.className = 'preset-divider';
      divider.textContent = 'Custom';
      grid.appendChild(divider);
    }
    const btn = document.createElement('button');
    btn.className = 'shape-btn' + (i === 0 ? ' active' : '');
    btn.dataset.shape = key;
    btn.title = shape.official ? `JetBrains expUI — ${shape.label}` : `Custom — ${shape.label}`;
    const vb = shape.viewBoxSize ?? 16;
    btn.innerHTML = `<svg width="24" height="24" viewBox="0 0 ${vb} ${vb}">${shape.preview}</svg>\n${shape.label}`;
    grid.appendChild(btn);
  });
}

document.getElementById('shapeGrid').addEventListener('click', e => {
  const btn = e.target.closest('.shape-btn');
  if (!btn) return;
  e.currentTarget.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  currentShape = btn.dataset.shape;
  const defaultScale = SHAPES[currentShape].defaultScale ?? 1.0;
  document.getElementById('shapeScale').value = defaultScale;
  document.getElementById('shapeScaleVal').textContent = defaultScale.toFixed(2);
  calibrateFontSize();
  render();
});

// ── Modifier Selection ────────────────────────────────────────────────
// ── Slider Labels ─────────────────────────────────────────────────────
function bindSlider(id, valId, decimals = 1) {
  const slider = document.getElementById(id);
  const val = document.getElementById(valId);
  slider.addEventListener('input', () => { val.textContent = parseFloat(slider.value).toFixed(decimals); render(); });
}

// ── Google Fonts ──────────────────────────────────────────────────────
async function loadGoogleFont() {
  const name = document.getElementById('googleFontName').value;
  const weight = document.getElementById('googleFontWeight').value;
  const status = document.getElementById('googleFontStatus');
  const btn = document.getElementById('googleFontLoad');

  if (!name.trim()) { status.textContent = 'Enter a font name.'; return; }
  currentFontKey = 'google-fonts';

  const effectiveWeight = styles.bold ? '700' : weight;
  const fontStyle = styles.italic ? 'italic' : 'normal';
  btn.textContent = '...';
  status.textContent = `Loading ${name} (${effectiveWeight} ${fontStyle})...`;

  const urls = getGoogleFontUrl(name, weight, styles.bold, styles.italic);
  let loaded = false;
  let lastError = null;

  for (const url of urls) {
    try {
      const resp = await fetch(url);
      if (!resp.ok) continue;
      const buf = await resp.arrayBuffer();
      currentFont = opentype.parse(buf);
      calibrateFontSize();
      status.innerHTML = `Loaded <b>${name}</b> (${effectiveWeight} ${fontStyle}) from fontsource`;
      loaded = true;
      clearError();
      saveFontSetting();
      render();
      break;
    } catch (e) {
      lastError = e;
    }
  }

  if (!loaded) {
    const hint = lastError
      ? `Font "${name}" was found but could not be parsed: <code>${lastError.message}</code>`
      : `Could not find "${name}". Check spelling — use the name as shown on <a href="https://fonts.google.com" target="_blank">fonts.google.com</a>.`;
    status.innerHTML = '';
    showError(hint);
  }
  btn.textContent = 'Load';
}

document.getElementById('googleFontLoad').addEventListener('click', loadGoogleFont);
document.getElementById('googleFontName').addEventListener('keydown', e => {
  if (e.key === 'Enter') loadGoogleFont();
});

// ── Font Select ───────────────────────────────────────────────────────
const googleFontsRow = document.getElementById('googleFontsRow');

document.getElementById('fontSelect').addEventListener('change', e => {
  googleFontsRow.style.display = e.target.value === 'google-fonts' ? 'block' : 'none';
  if (e.target.value === 'custom') {
    document.getElementById('fontFile').click();
  } else if (e.target.value === 'google-fonts') {
    document.getElementById('googleFontName').focus();
  } else {
    loadFont(e.target.value);
  }
});

document.getElementById('fontFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    try {
      currentFont = opentype.parse(evt.target.result);
      calibrateFontSize();
      render();
    } catch (err) {
      alert('Failed to parse font: ' + err.message);
    }
  };
  reader.readAsArrayBuffer(file);
});

// ── Style Toggles ────────────────────────────────────────────────────
document.querySelectorAll('.style-toggle[data-style]').forEach(btn => {
  btn.addEventListener('click', () => {
    const key = btn.dataset.style;
    styles[key] = !styles[key];
    btn.classList.toggle('active', styles[key]);
    if (currentFontKey === 'google-fonts') {
      loadGoogleFont();
    } else {
      loadFont(currentFontKey);
    }
  });
});

// ── Letter Input ──────────────────────────────────────────────────────
document.getElementById('letter').addEventListener('input', () => {
  calibrateFontSize();
  render();
});

// ── Preview Toggle Bindings ───────────────────────────────────────────
function setPreviewToggle(btnId, className, storageKey) {
  const btn = document.getElementById(btnId);
  const active = btn.classList.toggle('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.toggle(className));
  localStorage.setItem(storageKey, active);
}

document.getElementById('toggleCheckerboard').addEventListener('click', () => setPreviewToggle('toggleCheckerboard', 'checkerboard', 'preview-checkerboard'));
document.getElementById('togglePixelGrid').addEventListener('click', () => setPreviewToggle('togglePixelGrid', 'show-grid', 'preview-grid'));
document.getElementById('toggleGuideShape').addEventListener('click', () => setPreviewToggle('toggleGuideShape', 'show-guide-shape', 'preview-guide-shape'));
document.getElementById('toggleGuideLetter').addEventListener('click', () => setPreviewToggle('toggleGuideLetter', 'show-guide-letter', 'preview-guide-letter'));
document.getElementById('toggleGuideNotch').addEventListener('click', () => setPreviewToggle('toggleGuideNotch', 'show-guide-notch', 'preview-guide-notch'));
document.getElementById('toggleGuideBadge').addEventListener('click', () => setPreviewToggle('toggleGuideBadge', 'show-guide-badge', 'preview-guide-badge'));
document.getElementById('toggleOptimize').addEventListener('change', (e) => {
  svgoEnabled = e.target.checked;
  localStorage.setItem('svgo-enabled', svgoEnabled);
  render();
});

// ── Button Event Bindings ─────────────────────────────────────────────
document.getElementById('copyLight').addEventListener('click', e => copySVG('light', e.target));
document.getElementById('copyDark').addEventListener('click', e => copySVG('dark', e.target));
document.getElementById('downloadLight').addEventListener('click', () => downloadSVG('light'));
document.getElementById('downloadDark').addEventListener('click', () => downloadSVG('dark'));
document.getElementById('downloadBoth').addEventListener('click', downloadBoth);
document.getElementById('tabLight').addEventListener('click', () => switchTab('light'));
document.getElementById('tabDark').addEventListener('click', () => switchTab('dark'));

document.getElementById('resetSliders').addEventListener('click', (e) => {
  e.stopPropagation();
  const defaultScale = SHAPES[currentShape].defaultScale ?? 1.0;
  document.getElementById('shapeScale').value = defaultScale;
  document.getElementById('shapeScaleVal').textContent = defaultScale.toFixed(2);
  document.getElementById('xOffset').value = 0;
  document.getElementById('xOffsetVal').textContent = '0.0';
  document.getElementById('yOffset').value = 0;
  document.getElementById('yOffsetVal').textContent = '0.0';
  document.getElementById('strokeWidth').value = 1;
  document.getElementById('strokeWidthVal').textContent = '1.0';
  calibrateFontSize();
  render();
});

// ── Collapsible Section Animations ────────────────────────────────────
document.querySelectorAll('details.section').forEach(details => {
  const summary = details.querySelector('summary');

  summary.addEventListener('click', (e) => {
    // Don't intercept clicks on interactive children (e.g. Reset button)
    if (e.target !== summary && e.target.closest('button, a, input')) return;
    e.preventDefault();

    const isOpen = details.open;
    const summaryH = summary.offsetHeight;

    if (isOpen) {
      // Closing
      details.style.height = details.offsetHeight + 'px';
      details.style.overflow = 'hidden';
      requestAnimationFrame(() => {
        details.style.transition = 'height 0.2s ease';
        details.style.height = summaryH + 'px';
      });
      details.addEventListener('transitionend', function done() {
        details.removeEventListener('transitionend', done);
        details.open = false;
        details.style.height = '';
        details.style.overflow = '';
        details.style.transition = '';
      });
    } else {
      // Opening — set open but pin to collapsed height, then animate
      details.style.height = summaryH + 'px';
      details.style.overflow = 'hidden';
      details.open = true;
      const fullH = details.scrollHeight;
      requestAnimationFrame(() => {
        details.style.transition = 'height 0.2s ease';
        details.style.height = fullH + 'px';
      });
      details.addEventListener('transitionend', function done() {
        details.removeEventListener('transitionend', done);
        details.style.height = '';
        details.style.overflow = '';
        details.style.transition = '';
      });
    }
  });
});

// ── Preset Swatch Colors ──────────────────────────────────────────────
function updatePresetSwatches(themeKey) {
  const useLight = themeKey === 'islands-light';
  document.querySelectorAll('.preset-swatch').forEach(s => {
    s.style.background = useLight ? s.dataset.lightFill : s.dataset.darkFill;
    s.style.color = useLight ? s.dataset.lightStroke : s.dataset.darkStroke;
  });
}

// ── Site Theme Toggle ─────────────────────────────────────────────────
const themes = [
  { key: 'islands-dark', label: 'Islands Dark' },
  { key: 'islands-light', label: 'Islands Light' },
  { key: 'purple', label: 'Purple' },
];
let currentThemeIndex = 0;

function applyTheme(index) {
  currentThemeIndex = index;
  const theme = themes[index];
  document.documentElement.setAttribute('data-theme', theme.key);
  document.getElementById('themeLabel').textContent = theme.label;
  localStorage.setItem('site-theme', theme.key);
  updatePresetSwatches(theme.key);
}

document.getElementById('themeToggle').addEventListener('click', () => {
  applyTheme((currentThemeIndex + 1) % themes.length);
});

// Restore saved theme
const savedTheme = localStorage.getItem('site-theme');
if (savedTheme) {
  const idx = themes.findIndex(t => t.key === savedTheme);
  if (idx >= 0) applyTheme(idx);
}

// ── Init ──────────────────────────────────────────────────────────────
syncColor('lightFill', 'lightFillHex');
syncColor('lightStroke', 'lightStrokeHex');
syncColor('darkFill', 'darkFillHex');
syncColor('darkStroke', 'darkStrokeHex');

bindSlider('shapeScale', 'shapeScaleVal', 2);
bindSlider('fontSize', 'fontSizeVal');
bindSlider('yOffset', 'yOffsetVal');
bindSlider('xOffset', 'xOffsetVal');
bindSlider('strokeWidth', 'strokeWidthVal');
// Badge sliders: write values back to selected badge before render
for (const [sliderId, valId, dec, prop] of [
  ['badgeGap', 'badgeGapVal', 1, 'gap'],
  ['badgeXOffset', 'badgeXOffsetVal', 1, 'xOff'],
  ['badgeYOffset', 'badgeYOffsetVal', 1, 'yOff'],
  ['badgeScale', 'badgeScaleVal', 2, 'scale'],
]) {
  const slider = document.getElementById(sliderId);
  const val = document.getElementById(valId);
  slider.addEventListener('input', () => {
    val.textContent = parseFloat(slider.value).toFixed(dec);
    const b = badges.find(b => b.id === selectedBadgeId);
    if (b) b[prop] = parseFloat(slider.value);
    render();
  });
}

// ── Anchor Grid ───────────────────────────────────────────────────────
{
  const grid = document.getElementById('anchorGrid');
  const order = ['tl','t','tr','l','c','r','bl','b','br'];
  const flexMap = { 0: 'flex-start', 0.5: 'center', 1: 'flex-end' };
  for (const key of order) {
    const { ax, ay } = ANCHOR_POINTS[key];
    const cell = document.createElement('button');
    cell.className = 'anchor-cell' + (key === 'br' ? ' active' : '');
    cell.dataset.anchor = key;
    cell.title = key;
    cell.style.setProperty('--ax', flexMap[ax]);
    cell.style.setProperty('--ay', flexMap[ay]);
    const dot = document.createElement('span');
    dot.className = 'anchor-dot';
    cell.appendChild(dot);
    cell.addEventListener('click', () => {
      const b = badges.find(b => b.id === selectedBadgeId);
      if (b) b.anchor = key;
      grid.querySelectorAll('.anchor-cell').forEach(c => c.classList.toggle('active', c.dataset.anchor === key));
      render();
    });
    grid.appendChild(cell);
  }
}

document.getElementById('resetModifierSliders').addEventListener('click', () => {
  const b = badges.find(b => b.id === selectedBadgeId);
  if (b) {
    b.xOff = 0; b.yOff = 0; b.scale = 1; b.gap = 1; b.anchor = 'br';
  }
  loadTuningFromBadge(b);
  render();
});

// ── Badge List Management ─────────────────────────────────────────────
function addBadge(svgText, name) {
  if (!svgText || !svgText.includes('<svg')) return;
  const badge = {
    id: nextBadgeId++,
    svgText,
    name: name || 'custom.svg',
    anchor: 'br',
    xOff: 0, yOff: 0,
    scale: 1, gap: 1,
  };
  badges.push(badge);
  selectBadge(badge.id);
  renderBadgeList();
  render();
}

function removeBadge(id) {
  badges = badges.filter(b => b.id !== id);
  if (selectedBadgeId === id) {
    selectedBadgeId = badges.length > 0 ? badges[badges.length - 1].id : null;
  }
  loadTuningFromBadge(badges.find(b => b.id === selectedBadgeId));
  renderBadgeList();
  render();
}

function selectBadge(id) {
  selectedBadgeId = id;
  const b = badges.find(b => b.id === id);
  loadTuningFromBadge(b);
  // Highlight in list
  document.querySelectorAll('.badge-list-item').forEach(el => {
    el.classList.toggle('selected', +el.dataset.badgeId === id);
  });
}

function loadTuningFromBadge(b) {
  const tuning = document.getElementById('badgeTuning');
  if (!b) {
    tuning.style.display = 'none';
    return;
  }
  tuning.style.display = '';
  document.getElementById('badgeXOffset').value = b.xOff;
  document.getElementById('badgeXOffsetVal').textContent = b.xOff.toFixed(1);
  document.getElementById('badgeYOffset').value = b.yOff;
  document.getElementById('badgeYOffsetVal').textContent = b.yOff.toFixed(1);
  document.getElementById('badgeScale').value = b.scale;
  document.getElementById('badgeScaleVal').textContent = b.scale.toFixed(2);
  document.getElementById('badgeGap').value = b.gap;
  document.getElementById('badgeGapVal').textContent = b.gap.toFixed(1);
  // Anchor grid
  document.getElementById('anchorGrid').querySelectorAll('.anchor-cell').forEach(c =>
    c.classList.toggle('active', c.dataset.anchor === b.anchor));
}

function syncTuningToSelectedBadge() {
  const b = badges.find(b => b.id === selectedBadgeId);
  if (!b) return;
  b.xOff = parseFloat(document.getElementById('badgeXOffset').value);
  b.yOff = parseFloat(document.getElementById('badgeYOffset').value);
  b.scale = parseFloat(document.getElementById('badgeScale').value);
  b.gap = parseFloat(document.getElementById('badgeGap').value);
}

function renderBadgeList() {
  const list = document.getElementById('badgeList');
  list.innerHTML = '';
  for (const badge of badges) {
    const item = document.createElement('div');
    item.className = 'badge-list-item' + (badge.id === selectedBadgeId ? ' selected' : '');
    item.dataset.badgeId = badge.id;
    item.draggable = true;

    const handle = document.createElement('span');
    handle.className = 'drag-handle';
    handle.textContent = '\u2261';
    item.appendChild(handle);

    const thumb = document.createElement('div');
    thumb.style.cssText = 'width:20px;height:20px;flex-shrink:0';
    thumb.innerHTML = badge.svgText.replace(/width=["'][^"']*["']/i, 'width="20"').replace(/height=["'][^"']*["']/i, 'height="20"');
    item.appendChild(thumb);

    const name = document.createElement('span');
    name.className = 'badge-list-item-name';
    name.textContent = badge.name;
    item.appendChild(name);

    const removeBtn = document.createElement('button');
    removeBtn.className = 'badge-remove-btn';
    removeBtn.title = 'Remove';
    removeBtn.innerHTML = '&times;';
    removeBtn.addEventListener('click', e => { e.stopPropagation(); removeBadge(badge.id); });
    item.appendChild(removeBtn);

    item.addEventListener('click', () => selectBadge(badge.id));

    // Drag-to-reorder
    item.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', String(badge.id));
      e.dataTransfer.effectAllowed = 'move';
    });
    item.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      item.classList.add('drag-over');
    });
    item.addEventListener('dragleave', () => item.classList.remove('drag-over'));
    item.addEventListener('drop', e => {
      e.preventDefault();
      item.classList.remove('drag-over');
      const draggedId = +e.dataTransfer.getData('text/plain');
      if (draggedId === badge.id) return;
      const fromIdx = badges.findIndex(b => b.id === draggedId);
      const toIdx = badges.findIndex(b => b.id === badge.id);
      if (fromIdx < 0 || toIdx < 0) return;
      const [moved] = badges.splice(fromIdx, 1);
      badges.splice(toIdx, 0, moved);
      renderBadgeList();
      render();
    });

    list.appendChild(item);
  }
}

document.getElementById('badgeBrowseLink').addEventListener('click', e => {
  e.preventDefault();
  document.getElementById('badgeFileInput').click();
});

document.getElementById('badgeFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => addBadge(evt.target.result, file.name);
  reader.readAsText(file);
  e.target.value = '';
});

const badgeDropZone = document.getElementById('badgeDropZone');
badgeDropZone.addEventListener('dragover', e => { e.preventDefault(); badgeDropZone.classList.add('dragover'); });
badgeDropZone.addEventListener('dragleave', () => badgeDropZone.classList.remove('dragover'));
badgeDropZone.addEventListener('drop', e => {
  e.preventDefault();
  badgeDropZone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (!file || !file.name.endsWith('.svg')) return;
  const reader = new FileReader();
  reader.onload = evt => addBadge(evt.target.result, file.name);
  reader.readAsText(file);
});

badgeDropZone.addEventListener('paste', e => {
  const text = e.clipboardData.getData('text');
  if (text && text.includes('<svg')) {
    e.preventDefault();
    addBadge(text, 'pasted.svg');
  }
});

buildShapes();
buildPresets();
updatePresetSwatches(themes[currentThemeIndex].key);

// Restore preview toggles
if (localStorage.getItem('preview-checkerboard') === 'true') {
  document.getElementById('toggleCheckerboard').classList.add('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.add('checkerboard'));
}
if (localStorage.getItem('preview-grid') === 'true') {
  document.getElementById('togglePixelGrid').classList.add('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.add('show-grid'));
}
if (localStorage.getItem('preview-guide-shape') === 'true') {
  document.getElementById('toggleGuideShape').classList.add('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.add('show-guide-shape'));
}
if (localStorage.getItem('preview-guide-letter') === 'true') {
  document.getElementById('toggleGuideLetter').classList.add('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.add('show-guide-letter'));
}
if (localStorage.getItem('preview-guide-notch') === 'true') {
  document.getElementById('toggleGuideNotch').classList.add('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.add('show-guide-notch'));
}
if (localStorage.getItem('preview-guide-badge') === 'true') {
  document.getElementById('toggleGuideBadge').classList.add('active');
  document.querySelectorAll('.preview-zoomed').forEach(el => el.classList.add('show-guide-badge'));
}
document.getElementById('toggleOptimize').checked = svgoEnabled;

// Restore saved font or default to open-sans
const savedFont = JSON.parse(localStorage.getItem('font-setting') || 'null');
if (savedFont) {
  document.getElementById('fontSelect').value = savedFont.key;
  if (savedFont.key === 'google-fonts') {
    document.getElementById('googleFontsRow').style.display = 'block';
    document.getElementById('googleFontName').value = savedFont.name || '';
    document.getElementById('googleFontWeight').value = savedFont.weight || '600';
    loadGoogleFont();
  } else {
    loadFont(savedFont.key);
  }
} else {
  loadFont('open-sans');
}
</script>

</body>
</html>
